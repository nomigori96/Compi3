%{
#include <stdio.h>
#include <iostream>
#include "hw3_output.hpp"
#include "Semantic_types.hpp"
#include <string>
using namespace std;
using namespace output;

extern int yylineno;

int yylex();
void yyerror(const char*);

%}

%union {
    char character;
    int numeric;
    string str;
    exp_t exp;
    type_t type;
    enumType_t enumType;
    call_t call;
    expList_t expList;
    dummy_t dummy;
}

%token <character> B
%token <str> ID
%token <character> LPAREN
%nonassoc <character> RPAREN
%token <character> LBRACE
%token <character> RBRACE
%token <str> ENUM
%token <character> SC
%token <str> VOID
%token <character> COMMA
%token <str> RETURN
%token <str> BREAK
%token <str> IF
%token <str> CONTINUE
%nonassoc <str> ELSE
%token <str> WHILE
%token <str> INT
%token <str> BYTE
%token <str> BOOL
%token <numeric> NUM
%token <str> STRING
%token <str> TRUE
%token <str> FALSE
%right <character> ASSIGN
%left <character> OR
%left <character> AND
%left <character> EQUALITY
%nonassoc <character> RELATIONAL
%left <character> ADDITIVE
%left <character> MUL
%right <dummy> CAST
%right <str> NOT
%left <dummy> PARENS

%type <dummy> Program
%type <dummy> Funcs
%type <dummy> FuncDecl
%type <dummy> Enums
%type <dummy> EnumDecl
%type <dummy> RetType
%type <dummy> Formals
%type <dummy> FormalsList
%type <dummy> FormalsDecl
%type <dummy> EnumeratorList
%type <dummy> Enumerator
%type <dummy> Statements
%type <dummy> Statement
%type <call> Call
%type <expList> ExpList
%type <type> Type
%type <enumType> EnumType
%type <exp> Exp

%%

Program:            CreateSymbolTable Enums Funcs {};
CreateSymbolTable:  {};
Funcs:              {} |
                    FuncDecl Funcs {};
FuncDecl:           RetType ID LPAREN Formals RPAREN LBRACE OpenScope Statements RBRACE CloseScope {};
OpenScope:          {};
CloseScope:         {};
Enums:              {}|
                    EnumDecl Enums {};
EnumDecl:           ENUM ID LBRACE EnumeratorList RBRACE SC {};
RetType:            Type {}|
                    VOID {};
Formals:            {}|
                    FormalsList {};
FormalsList:        FormalDecl {}|
                    FormalDecl COMMA FormalsList {};
FormalDecl:         Type ID {}|
                    EnumType ID {};
EnumeratorList:     Enumerator {}|
                    EnumeratorList COMMA Enumerator {};
Enumerator:         ID {};
Statements:         Statement {}|
                    Statements Statement {};
Statement:          LBRACE OpenScope Statements RBRACE CloseScope {}|
                    Type ID SC {}|
                    EnumType ID SC {}|
                    EnumDecl {}|
                    Type ID ASSIGN Exp SC {}|
                    EnumType ID ASSIGN Exp SC {}|
                    ID ASSIGN Exp SC {}|
                    Call SC {}|
                    RETURN SC {}|
                    RETURN Exp SC {}|
                    IF LPAREN Exp RPAREN  OpenScope Statement CloseScope {}|
                    IF LPAREN Exp RPAREN OpenScope Statement CloseScope ELSE OpenScope Statement CloseScope {}|
                    WHILE LPAREN Exp RPAREN OpenScope Statement CloseScope {}|
                    BREAK SC {}|
                    CONTINUE SC {};
Call:               ID LPAREN ExpList RPAREN {}|
                    ID LPAREN RPAREN {};
ExpList:            Exp {}|
                    Exp COMMA ExpList {};
Type:               INT {}|
                    BYTE {}|
                    BOOL {};
EnumType:           ENUM ID {};
Exp:                LPAREN Exp RPAREN %prec PARENS {}|
                    Exp ADDITIVE Exp {}|
                    Exp MUL Exp {}|
                    ID {}|
                    Call {}|
                    NUM {}|
                    NUM B {}|
                    STRING {}|
                    TRUE {}|
                    FALSE {}|
                    NOT Exp {}|
                    Exp AND Exp {}|
                    Exp OR Exp {}|
                    Exp RELATIONAL Exp {}|
                    Exp EQUALITY Exp {}|
                    LPAREN Type RPAREN Exp %prec CAST {};

%%

void yyerror(const char*){
    errorSyn(yylineno);
    exit(0);
}

int main(){
    return yyparse();
}