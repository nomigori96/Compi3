%{
#include "hw3_output.hpp"
#include "Semantic_types.hpp"
#include "ParserFunctions.hpp"
#include <string>

using namespace std;
using namespace output;

extern int yylineno;

int yylex();
void yyerror(const char*);


%}

%union {
    char character;
    int numeric;
    string str;
    exp_t exp;
    type_t type;
    enumType_t enumType;
    call_t call;
    expList_t expList;
    dummy_t dummy;
    formals_t formals;
    formalList_t formalsList;
    formalDecl_t formalsDecl;
    retType_t retType;
    enumeratorList_t enumeratorList;
	declareEnumVar_t declareEnumVar;
}

%token <character> B
%token <str> ID
%token <character> LPAREN
%nonassoc <character> RPAREN
%token <character> LBRACE
%token <character> RBRACE
%token <str> ENUM
%token <character> SC
%token <str> VOID
%token <character> COMMA
%token <str> RETURN
%token <str> BREAK
%token <str> IF
%token <str> CONTINUE
%nonassoc <str> ELSE
%token <str> WHILE
%token <str> INT
%token <str> BYTE
%token <str> BOOL
%token <numeric> NUM
%token <str> STRING
%token <str> TRUE
%token <str> FALSE
%right <character> ASSIGN
%left <character> OR
%left <character> AND
%left <character> EQUALITY
%nonassoc <character> RELATIONAL
%left <character> ADDITIVE
%left <character> MUL
%right <dummy> CAST
%right <str> NOT
%left <dummy> PARENS

%type <dummy> Program
%type <dummy> Funcs
%type <dummy> FuncDecl
%type <dummy> Enums
%type <dummy> EnumDecl
%type <retType> RetType
%type <formals> Formals
%type <formalsList> FormalsList
%type <formalsDecl> FormalsDecl
%type <enumeratorList> EnumeratorList
%type <dummy> Enumerator
%type <dummy> Statements
%type <dummy> Statement
%type <call> Call
%type <expList> ExpList
%type <type> Type
%type <enumType> EnumType
%type <exp> Exp
%type <dummy> FuncDeclHeader
%type <dummy> OpenScope
%type <dummy> CloseScope
%type <dummy> IfHeader
%type <dummy> WhileHeader
%type <declareEnumVar> DeclareEnumVar 

%%

Program:            Enums Funcs {
                        CheckMainExists()
                    };
Funcs:              |
                    FuncDecl Funcs ;
FuncDecl:           FuncDeclHeader Statements RBRACE {
                        CloseCurrentScope();
                    };
FuncDeclHeader:     RetType ID LPAREN Formals RPAREN LBRACE {
						//TODO - If we do check the formals are not shadowing inside the formals, we need to insert the symbol for the function before we get to the formals part (change the grammer)
                        AddFunctionSymbolIfNotExists($2, *($4.args), *($1.type));
                        UpdateCurrFunctionRetType(*($1.type));
                        OpenNewScope();
                        AddFuncArgsToSymbolTable(*($4.args));
                        delete $4.args;
                        delete $1.type;
                    };
OpenScope:          {
                        OpenNewScope();
                    };
CloseScope:         {
                        CloseCurrentScope();
                    };
Enums:              |
                    EnumDecl Enums ;
EnumDecl:           ENUM ID LBRACE EnumeratorList RBRACE SC {
                        AddEnumSymbolIfNotExists($2, *($4.values));
                        delete $4.values;
                    };
RetType:            Type {$$.type = $1.type;}|
                    VOID {$$.type = new string("void");};
Formals:            {
                        $$.args = new vector<tuple<string, string, bool>>();
                    }|
                    FormalsList {
                        $$.args = $1.args;
                    };
FormalsList:        FormalDecl {
                        $$.args = new vector<tuple<string,string, bool>>();
                        tuple<string,string, bool>* argToAdd(*($1.type),
                                                             *($1.argName),
                                                             $1.is_enum_type);
                        $$.args.push_back(argToAdd);
                        delete $1.type;
                        delete $1.argName;
                    }|
                    FormalDecl COMMA FormalsList {
                        $$.args = $3.args;
                        tuple<string,string, bool>* argToAdd(*($1.type),
                                                             *($1.argName),
                                                             $1.is_enum_type);
                        $$.args.insert(*($$.args).begin(), argToAdd);
                        delete $1.type;
                        delete $1.argName;
                    };
FormalDecl:         Type ID {
						//TODO - maybe we should check here if ID already exists in symbol_table?? because the error prints the line number
                        $$.type = $1.type;
                        $$.argName = new string($2);
                        $$.isEnumType = false;
                    }|
                    EnumType ID {
						//TODO - maybe we should check here if ID already exists in symbol_table?? because the error prints the line number
						CheckEnumTypeDefined(*($1.typeName), $2);
                        $$.type = $1.typeName;
                        $$.argName = new string($2);
                        $$.isEnumType = true;
                    };
EnumeratorList:     Enumerator {
                        $$.values = new vector<string>();
                        $$.values->push_back(*($1.value));
                        delete $1.value;
                    }|
                    EnumeratorList COMMA Enumerator {
                        $$.values = $1.values;
                        $$.values->push_back(*($3.value));
                        delete $3.value;
                    };
Enumerator:         ID {
                        $$.value = new string($1);
                    };
Statements:         Statement |
                    Statements Statement ;
Statement:          LBRACE OpenScope Statements RBRACE {
                        CloseCurrentScope();
                    }|
                    Type ID SC {
                        AddVariableSymbolIfNotExists($2, *($1.type), false);
                        delete $1.type;
                    }|
                    DeclareEnumVar SC {
						delete $1.fullType;
						delete $1.id;
					}|
                    EnumDecl |
                    Type ID ASSIGN Exp SC {
                        HandleAssignment(*($1.type), *($4.type), $2);
                        delete $1.type;
                        delete $4.type;
                    }|
                    DeclareEnumVar ASSIGN Exp SC {
						//TODO - again lineno can be wrong if there are a lot of empty lines before the SC
                        HandleEnumAssignment(*($1.fullType), *($4.type), *($1.id));
                        delete $1.typeName;
						delete $1.fullType;
                        delete $4.type;
                    }|
                    ID ASSIGN Exp SC {
                        HandleAssignmentForExistingVar($1, *($3.type));
                        delete $3.type;
                    }|
                    Call SC {
                        delete $1.type;
                    }|
                    RETURN SC {
                        CheckReturnValid("void");
                    }|
                    RETURN Exp SC {
                        CheckReturnValid(*($2.type));
                        delete $2.type;
                    }|
                    IfHeader Statement {
                        CloseCurrentScope();
                    }|
                    IfHeader Statement CloseScope ELSE OpenScope Statement {
                        CloseCurrentScope();
                    }|
                    WhileHeader Statement {
                        FlipLoopStatus();
                        CloseCurrentScope();
                    }|
                    BREAK SC {
                        CheckIfBreakInLoop();
                    }|
                    CONTINUE SC {
                        CheckIfContinueInLoop();
                    };
DeclareEnumVar:		EnumType ID {	
						CheckEnumTypeDefined(*($1.typeName), $2);
						CheckIfIdAlreadyExists($2);
						AddVariableSymbol($2, *($1.fullType), true);
						$$.fullType = $1.fullType;
						$$.id = new string ($2);
					};
IfHeader:           IF LPAREN Exp RPAREN {
                        vector<string> expected(1, "bool");
                        CheckTypesMatch(expected, *($3.type));
                        OpenNewScope();
                    };
WhileHeader:        WHILE LPAREN Exp RPAREN {
                        vector<string> expected(1, "bool");
                        CheckTypesMatch(expected, *($3.type));
                        FlipLoopStatus();
                        OpenNewScope();
                    };
Call:               ID LPAREN ExpList RPAREN {
                        $$.type = new string(checkFunction($1, *($3.types)));
                        delete $3.types;
                    }|
                    ID LPAREN RPAREN {
                        $$.type = new string(checkFunction($1, vector<string>()));
                    };
ExpList:            Exp {
                        $$.types = new vector<string>();
                        $$.types->push_back(*($1.type));
                        delete $1.type;
                    }|
                    Exp COMMA ExpList {
                        $3.types->insert($3.types->begin(), *($1.type));
                        $$.types = $3.types;
                        delete $1.type;
                    };
Type:               INT {$$.type = new string("int");}|
                    BYTE {$$.type = new string("byte");}|
                    BOOL {$$.type = new string("bool");};
EnumType:           ENUM ID {
						string enum_str = string("enum ");
						string full_type = enum_str + $2;
                        $$.fullType = new string(full_type);
						$$.typeName = new string($2);
                    };
Exp:                LPAREN Exp RPAREN %prec PARENS {
                        $$.type = $2.type;
                    }|
                    Exp ADDITIVE Exp {
                        vector<string> expected;
                        expected.push_back("int");
                        expected.push_back("byte");
                        CheckTypesMatch(expected, *($1.type));
                        CheckTypesMatch(expected, *($3.type));
                        $$.type = new string(DetermineBinopReturnType(*($1.type), *($3.type)));
                        delete $1.type;
                        delete $3.type;
                    }|
                    Exp MUL Exp {
                        vector<string> expected;
                        expected.push_back("int");
                        expected.push_back("byte");
                        CheckTypesMatch(expected, *($1.type));
                        CheckTypesMatch(expected, *($3.type));
                        $$.type = new string(DetermineBinopReturnType(*($1.type), *($3.type)));
                        delete $1.type;
                        delete $3.type;
                    }|
                    ID {
                        $$.type = new string(GetExpressionTypeById($1));
                    }|
                    Call {
                        $$.type = $1.type;
                    }|
                    NUM {
                        $$.type = new string("int");
                    }|
                    NUM B {
                        CheckNumValidity($1);
                        $$.type = new string("byte");
                    }|
                    STRING {
                        $$.type = new string("string");
                    }|
                    TRUE {
                        $$.type = new string("bool");
                    }|
                    FALSE {
                        $$.type = new string("bool");
                    }|
                    NOT Exp {
                        vector<string> expected(1, "bool");
                        CheckTypesMatch(expected, *($2.type));
                        $$.type = $2.type;
                    }|
                    Exp AND Exp {
                        vector<string> expected(1, "bool");
                        CheckTypesMatch(expected, *($1.type));
                        CheckTypesMatch(expected, *($3.type));
                        $$.type = $1.type;
                    }|
                    Exp OR Exp {
                        vector<string> expected(1, "bool");
                        CheckTypesMatch(expected, *($1.type));
                        CheckTypesMatch(expected, *($3.type));
                        $$.type = $1.type;
                    }|
                    Exp RELATIONAL Exp {
                        vector<string> expected;
                        expected.push_back("int");
                        expected.push_back("byte");
                        CheckTypesMatch(expected, *($1.type));
                        CheckTypesMatch(expected, *($3.type));
                        $$.type = new string("bool");
                        delete $1.type;
                        delete $3.type;
                    }|
                    Exp EQUALITY Exp {
                        vector<string> expected;
                        expected.push_back("int");
                        expected.push_back("byte");
                        CheckTypesMatch(expected, *($1.type));
                        CheckTypesMatch(expected, *($3.type));
                        $$.type = new string("bool");
                        delete $1.type;
                        delete $3.type;
                    }|
                    LPAREN Type RPAREN Exp %prec CAST {
						IsExplicitCastAllowed($2.type, $4.type);
						delete $2.type;
                        delete $4.type;
                    };

%%

void yyerror(const char*){
    errorSyn(yylineno);
    exit(0);
}

int main(){
    return yyparse();
}