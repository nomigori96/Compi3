%{
#include <stdio.h>
#include <iostream>
#include "hw3_output.hpp"
#include "Semantic_types.hpp"
#include "ParserFunctions.hpp"
#include <string>
using namespace std;

extern int yylineno;

int yylex();
void yyerror(const char*);


%}

%union {
    char character;
    int numeric;
    string str;
    exp_t exp;
    type_t type;
    enumType_t enumType;
    call_t call;
    expList_t expList;
    dummy_t dummy;
    formals_t formals;
    formalList_t formalsList;
    formalDecl_t formalsDecl;
    retType_t retType;
}

%token <character> B
%token <str> ID
%token <character> LPAREN
%nonassoc <character> RPAREN
%token <character> LBRACE
%token <character> RBRACE
%token <str> ENUM
%token <character> SC
%token <str> VOID
%token <character> COMMA
%token <str> RETURN
%token <str> BREAK
%token <str> IF
%token <str> CONTINUE
%nonassoc <str> ELSE
%token <str> WHILE
%token <str> INT
%token <str> BYTE
%token <str> BOOL
%token <numeric> NUM
%token <str> STRING
%token <str> TRUE
%token <str> FALSE
%right <character> ASSIGN
%left <character> OR
%left <character> AND
%left <character> EQUALITY
%nonassoc <character> RELATIONAL
%left <character> ADDITIVE
%left <character> MUL
%right <dummy> CAST
%right <str> NOT
%left <dummy> PARENS

%type <dummy> Program
%type <dummy> Funcs
%type <dummy> FuncDecl
%type <dummy> Enums
%type <dummy> EnumDecl
%type <retType> RetType
%type <formals> Formals
%type <formalsList> FormalsList
%type <formalsDecl> FormalsDecl
%type <dummy> EnumeratorList
%type <dummy> Enumerator
%type <dummy> Statements
%type <dummy> Statement
%type <call> Call
%type <expList> ExpList
%type <type> Type
%type <enumType> EnumType
%type <exp> Exp

%%

Program:            Enums Funcs {program_enum_funcs()};
Funcs:              {} |
                    FuncDecl Funcs {};
FuncDecl:           FuncDeclHeader Statements RBRACE {
    CloseCurrentScope();
};
FuncDeclHeader:     RetType ID LPAREN Formals RPAREN LBRACE {
    AddFunctionSymbolIfNotExists($2, "function" , $4.args, $1.type);
    OpenNewScope();
    AddFuncArgsToSymbolTable(*$4.args);
    delete $4.args;
    delete $1.type;
};
OpenScope:          {
    OpenNewScope();
};
CloseScope: {
    CloseCurrentScope();
};
Enums:              {}|
                    EnumDecl Enums {};
EnumDecl:           ENUM ID LBRACE EnumeratorList RBRACE SC {};
RetType:            Type {$$.type = $1.type;}|
                    VOID {$$.type = new string("void");};
Formals:            {
    $$.args = new vector<pair<string, string>>();
}|
                    FormalsList {
    $$.args = $1.args;
};
FormalsList:        FormalDecl {
    $$.args = new vector<pair<string,string>>();
    pair<string,string>* argToAdd(*($1.type), *($1,argName));
    $$.args.push_back(argToAdd);
    delete $1.type;
    delete $1.argName;
}|
                    FormalDecl COMMA FormalsList {
    $$.args = $3.args;
    pair<string,string>* argToAdd(*($1.type), *($1.argName));
    $$.args.insert(*($$.args).begin(), argToAdd);
    delete $1.type;
    delete $1.argName;
};
FormalDecl:         Type ID {
    $$.type = $1.type;
    $$.argName = new string($2);
}|
                    EnumType ID {};
EnumeratorList:     Enumerator {}|
                    EnumeratorList COMMA Enumerator {};
Enumerator:         ID {};
Statements:         Statement {}|
                    Statements Statement {};
Statement:          LBRACE OpenScope Statements RBRACE CloseScope {}|
                    Type ID SC {}|
                    EnumType ID SC {}|
                    EnumDecl {}|
                    Type ID ASSIGN Exp SC {}|
                    EnumType ID ASSIGN Exp SC {}|
                    ID ASSIGN Exp SC {}|
                    Call SC {}|
                    RETURN SC {}|
                    RETURN Exp SC {}|
                    IF LPAREN Exp RPAREN  OpenScope Statement CloseScope {}|
                    IF LPAREN Exp RPAREN OpenScope Statement CloseScope ELSE OpenScope Statement CloseScope {}|
                    WHILE LPAREN Exp RPAREN OpenScope Statement CloseScope {}|
                    BREAK SC {}|
                    CONTINUE SC {};
Call:               ID LPAREN ExpList RPAREN {}|
                    ID LPAREN RPAREN {};
ExpList:            Exp {}|
                    Exp COMMA ExpList {};
Type:               INT {$$.type = new string("int");}|
                    BYTE {$$.type = new string("byte");}|
                    BOOL {$$.type = new string("bool");};
EnumType:           ENUM ID {};
Exp:                LPAREN Exp RPAREN %prec PARENS {}|
                    Exp ADDITIVE Exp {}|
                    Exp MUL Exp {}|
                    ID {}|
                    Call {}|
                    NUM {}|
                    NUM B {}|
                    STRING {}|
                    TRUE {}|
                    FALSE {}|
                    NOT Exp {}|
                    Exp AND Exp {}|
                    Exp OR Exp {}|
                    Exp RELATIONAL Exp {}|
                    Exp EQUALITY Exp {}|
                    LPAREN Type RPAREN Exp %prec CAST {};

%%

void yyerror(const char*){
    errorSyn(yylineno);
    exit(0);
}

int main(){
    return yyparse();
}