%{
#include "hw3_output.hpp"
#include "Semantic_types.hpp"
#include "ParserFunctions.hpp"
#include <string>

using namespace std;

extern int yylineno;

int yylex();
void yyerror(const char*);


%}

%union {
    char character;
    int numeric;
    string str;
    exp_t exp;
    type_t type;
    enumType_t enumType;
    call_t call;
    expList_t expList;
    dummy_t dummy;
    formals_t formals;
    formalList_t formalsList;
    formalDecl_t formalsDecl;
    retType_t retType;
    enumeratorList_t enumeratorList;
    funcIdDecl_t funcIdDecl;
    enumIdDecl_t enumIdDecl;

}

%token <character> B
%token <str> ID
%token <character> LPAREN
%nonassoc <character> RPAREN
%token <character> LBRACE
%token <character> RBRACE
%token <str> ENUM
%token <character> SC
%token <str> VOID
%token <character> COMMA
%token <str> RETURN
%token <str> BREAK
%token <str> IF
%token <str> CONTINUE
%nonassoc <str> ELSE
%token <str> WHILE
%token <str> INT
%token <str> BYTE
%token <str> BOOL
%token <numeric> NUM
%token <str> STRING
%token <str> TRUE
%token <str> FALSE
%right <character> ASSIGN
%left <character> OR
%left <character> AND
%left <character> EQUALITY
%nonassoc <character> RELATIONAL
%left <character> ADDITIVE
%left <character> MUL
%right <dummy> CAST
%right <str> NOT
%left <dummy> PARENS

%type <dummy> Program
%type <dummy> Funcs
%type <dummy> FuncDecl
%type <dummy> Enums
%type <dummy> EnumDecl
%type <retType> RetType
%type <formals> Formals
%type <formalsList> FormalsList
%type <formalsDecl> FormalsDecl
%type <enumeratorList> EnumeratorList
%type <dummy> Enumerator
%type <dummy> Statements
%type <dummy> Statement
%type <call> Call
%type <expList> ExpList
%type <type> Type
%type <enumType> EnumType
%type <exp> Exp
%type <dummy> FuncDeclHeader
%type <dummy> OpenScope
%type <dummy> CloseScope
%type <dummy> IfHeader
%type <dummy> WhileHeader
%type <funcIdDecl> FuncIdDecl
%type <enumIdDecl> EnumIdDecl

%%

Program:            Enums Funcs {
                        CheckMainExists();
                        CloseCurrentScope();
                    };
Funcs:               |
                    FuncDecl Funcs ;
FuncDecl:           FuncDeclHeader Statements RBRACE {
                        CloseCurrentScope();
                    };
FuncIdDecl:         RetType ID {
                        AddFunctionSymbolIfNotExists($2, *($1.type));
                        UpdateCurrFunctionRetType(*($1.type));
                        $$.funcId = new string($2);
                    };
FuncDeclHeader:     FuncIdDecl LPAREN Formals RPAREN LBRACE {
                        UpdateFunctionSymbolArgs(*($3.args), *($1.funcId))
                        OpenNewScope();
                        AddFuncArgsToSymbolTable(*($4.args));
                        delete $4.args;
                        delete $1.type;
                    };
OpenScope:          {
                        OpenNewScope();
                    };
CloseScope:         {
                        CloseCurrentScope();
                    };
Enums:              |
                    EnumDecl Enums ;
EnumIdDecl:         ENUM ID {
                        AddEnumSymbolIfNotExists($2);
                        $$.enumId = new string($2);
                    };
EnumDecl:           EnumIdDecl LBRACE EnumeratorList RBRACE SC {
                        UpdateEnumSymbolValues(*($3.values), $1.enumId);
                        delete $4.values;
                    };
RetType:            Type {$$.type = $1.type;}|
                    VOID {$$.type = new string("void");};
Formals:            {
                        $$.args = new vector<tuple<string, string, bool>>();
                    }|
                    FormalsList {
                        $$.args = $1.args;
                    };
FormalsList:        FormalDecl {
                        $$.args = new vector<tuple<string,string, bool>>();
                        tuple<string,string, bool>* argToAdd(*($1.type),
                                                             *($1.argName),
                                                             $1.is_enum_type);
                        $$.args.push_back(argToAdd);
                        delete $1.type;
                        delete $1.argName;
                    }|
                    FormalDecl COMMA FormalsList {
                        $$.args = $3.args;
                        CheckNoDuplicatesFormalList(*($3.args), *($1.argName));
                        tuple<string,string, bool>* argToAdd(*($1.type),
                                                             *($1.argName),
                                                             $1.is_enum_type);
                        $$.args.insert(*($$.args).begin(), argToAdd);
                        delete $1.type;
                        delete $1.argName;
                    };
FormalDecl:         Type ID {
                        CheckIfIdIsShadowing($2);
                        $$.type = $1.type;
                        $$.argName = new string($2);
                        $$.isEnumType = false;
                    }|
                    EnumType ID {
                        CheckIfIdIsShadowing($2);
                        CheckIfEnumTypeIsDefined(*($1.typeName), $2);
                        $$.type = new string(*($1.typeName));
                        $$.argName = new string($2);
                        $$.isEnumType = true;
                        delete $1.typeName;
                    };
EnumeratorList:     Enumerator {
                        $$.values = new vector<string>();
                        $$.values->push_back(*($1.value));
                        delete $1.value;
                    }|
                    EnumeratorList COMMA Enumerator {
                        $$.values = $1.values;
                        CheckNoDuplicatesEnumList($$.values, *($3.value));
                        $$.values->push_back(*($3.value));
                        delete $3.value;
                    };
Enumerator:         ID {
                        CheckIfIdIsShadowing($1);
                        $$.value = new string($1);
                    };
Statements:         Statement {}|
                    Statements Statement {};
Statement:          LBRACE OpenScope Statements RBRACE {
                        CloseCurrentScope();
                    }|
                    Type ID SC {
                        AddVariableSymbolIfNotExists($2, *($1.type), false);
                        delete $1.type;
                    }|
                    EnumType ID SC {
                        CheckIfEnumTypeIsDefined(*($1.typeName), $2);
                        AddVariableSymbolIfNotExists($2, *($1.typeName), true);
                        delete $1.typeName;
                    }|
                    EnumDecl |
                    Type ID ASSIGN Exp SC {
                        AddVariableSymbolIfNotExists($2, *($1.type), false);
                        CheckIfAssignmentAllowed(*($1.type), *($4.type));
                        delete $1.type;
                        delete $4.type;
                    }|
                    EnumType ID ASSIGN Exp SC {
                        CheckIfEnumTypeIsDefined(*($1.typeName), $2);
                        CheckIfAssignmentAllowedEnum(*($1.typeName), *($4.type), $2);
                        AddVariableSymbolIfNotExists($2, *($1.typeName), false);
                        delete $1.typeName;
                        delete $4.type;
                    }|
                    ID ASSIGN Exp SC {
                        HandleAssignmentForExistingVar($1, *($3.type));
                        delete $3.type;
                    }|
                    Call SC {
                        delete $1.type;
                    }|
                    RETURN SC {
                        CheckReturnValid("void");
                    }|
                    RETURN Exp SC {
                        CheckReturnValid(*($2.type));
                        delete $2.type;
                    }|
                    IfHeader Statement {
                        CloseCurrentScope();
                    }|
                    IfHeader Statement CloseScope ELSE OpenScope Statement {
                        CloseCurrentScope();
                    }|
                    WhileHeader Statement {
                        FlipLoopStatus();
                        CloseCurrentScope();
                    }|
                    BREAK SC {
                        CheckIfBreakInLoop();
                    }|
                    CONTINUE SC {
                        CheckIfContinueInLoop();
                    };
IfHeader:           IF LPAREN Exp RPAREN {
                        vector<string> expected(1, "BOOL");
                        CheckTypesMatch(expected, *($3.type));
                        OpenNewScope();
                    };
WhileHeader:        WHILE LPAREN Exp RPAREN {
                        vector<string> expected(1, "BOOL");
                        CheckTypesMatch(expected, *($3.type));
                        FlipLoopStatus();
                        OpenNewScope();
                    };
Call:               ID LPAREN ExpList RPAREN {
                        $$.type = new string(checkFunction($1, *($3.types)));
                        delete $3.types;
                    }|
                    ID LPAREN RPAREN {
                        $$.type = new string(checkFunction($1, vector<string>()));
                    };
ExpList:            Exp {
                        $$.types = new vector<string>();
                        $$.types->push_back(*($1.type));
                        delete $1.type;
                    }|
                    Exp COMMA ExpList {
                        $3.types->insert($3.types->begin(), *($1.type));
                        $$.types = $3.types;
                        delete $1.type;
                    };
Type:               INT {$$.type = new string("INT");}|
                    BYTE {$$.type = new string("BYTE");}|
                    BOOL {$$.type = new string("BOOL");};
EnumType:           ENUM ID {
                        string fullType = string("enum ") + string($2);
                        $$.typeName = new string(fullType);
                    };
Exp:                LPAREN Exp RPAREN %prec PARENS {
                        $$.type = $2.type;
                    }|
                    Exp ADDITIVE Exp {
                        vector<string> expected;
                        expected.push_back("INT");
                        expected.push_back("BYTE");
                        CheckTypesMatch(expected, *($1.type));
                        CheckTypesMatch(expected, *($3.type));
                        $$.type = new string(DetermineBinopReturnType(*($1.type), *($3.type)));
                        delete $1.type;
                        delete $3.type;
                    }|
                    Exp MUL Exp {
                        vector<string> expected;
                        expected.push_back("INT");
                        expected.push_back("BYTE");
                        CheckTypesMatch(expected, *($1.type));
                        CheckTypesMatch(expected, *($3.type));
                        $$.type = new string(DetermineBinopReturnType(*($1.type), *($3.type)));
                        delete $1.type;
                        delete $3.type;
                    }|
                    ID {
                        $$.type = new string(GetExpressionTypeById($1));
                    }|
                    Call {
                        $$.type = $1.type;
                    }|
                    NUM {
                        $$.type = new string("INT");
                    }|
                    NUM B {
                        CheckNumValidity($1);
                        $$.type = new string("BYTE");
                    }|
                    STRING {
                        $$.type = new string("STRING");
                    }|
                    TRUE {
                        $$.type = new string("BOOL");
                    }|
                    FALSE {
                        $$.type = new string("BOOL");
                    }|
                    NOT Exp {
                        vector<string> expected(1, "BOOL");
                        CheckTypesMatch(expected, *($2.type));
                        $$.type = $2.type;
                    }|
                    Exp AND Exp {
                        vector<string> expected(1, "BOOL");
                        CheckTypesMatch(expected, *($1.type));
                        CheckTypesMatch(expected, *($3.type));
                        $$.type = $1.type;
                    }|
                    Exp OR Exp {
                        vector<string> expected(1, "BOOL");
                        CheckTypesMatch(expected, *($1.type));
                        CheckTypesMatch(expected, *($3.type));
                        $$.type = $1.type;
                    }|
                    Exp RELATIONAL Exp {
                        vector<string> expected;
                        expected.push_back("INT");
                        expected.push_back("BYTE");
                        CheckTypesMatch(expected, *($1.type));
                        CheckTypesMatch(expected, *($3.type));
                        $$.type = new string("BOOL");
                        delete $1.type;
                        delete $3.type;
                    }|
                    Exp EQUALITY Exp {
                        vector<string> expected;
                        expected.push_back("INT");
                        expected.push_back("BYTE");
                        CheckTypesMatch(expected, *($1.type));
                        CheckTypesMatch(expected, *($3.type));
                        $$.type = new string("BOOL");
                        delete $1.type;
                        delete $3.type;
                    }|
                    LPAREN Type RPAREN Exp %prec CAST {
                        isExplicitCastAllowed(*($2.type), *($4.type));
                    };

%%

void yyerror(const char*){
    errorSyn(yylineno);
    exit(0);
}

int main(){
    return yyparse();
}